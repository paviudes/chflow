import os
import sys

def CheckDependencies():
	# Check if all the requires packages exist
	# if not, create a requirements text file.
	packages = [["scipy", "0.18", "linear algebra"],
				["numpy", "0.12", "matrix operations"],
				["picos", "1.0", "semi-definite programs, eg. Diamond norm"],
				["cvxopt", "1.0", "semi-definite programs, eg. Diamond norm"],
				["multiprocessing", "1.0", "parallel computations"],
				["sklearn", "1.0", "machine learning"],
				["matplotlib", "1.0", "plotting"]]
	missing = []
	for i in range(len(packages)):
		try:
			exec("import %s" % (packages[i][0]))
		except:
			missing.append(packages[i])
	if (len(missing) > 0):
		print("\033[2mMissing or outdated packages might affect certain functionalities.\033[2m")
		print("\033[2m{:<20} | {:<10} | {:<20}\033[0m".format("Package", "Version", "Affected functionality"))
		print("\033[2m{:<50}\033[0m".format("--------------------------------------------------------------"))
		for i in range(len(missing)):
			print("\033[2m{:<20} | {:<10} | {:<20}\033[0m".format(missing[i][0], missing[i][1], missing[i][2]))
		print("\033[2mxxxxxx\033[0m")
		with open("./../requirements.txt", "w") as fp:
			fp.write("# Install the missing packages using pip install -r requirements.txt\n")
			for i in range(len(missing)):
				fp.write("%s>=%s\n" % (missing[i][0], missing[i][1]))
		print("\033[2mTo install all missing packages, run \"pip install -r requirements.txt\".\033[0m")
	return None


def BuildExt(loc, cython, compiler = "gcc"):
	# Build all the cython (or c) extensions for simulations.
	# For the build to work, a script containing the setup(...) function must be called from shell with additional arguments.
	# Hence, in this function, we will call the parent script setup.py with the necessary shell arguments for successfully building the required Cython files.
	# When the parent script is called, only the content under if __name__ == 'main' will be executed.
	os.system("cd %s;python ./../setup.py build_ext --inplace %d %s;cd .." % (loc, cython, compiler))
	return None


def Clean(dist = 0):
	# Clean up all the files that are associated with compilation and execution.
	# Remove the files generated by the Cython compiler -- *.c and *.so and build/ directory in the simulate/ folder.
	if (not (os.path.exists("./../.ignore/"))):
		os.mkdir("./../.ignore/")
	# Remove all latex generated files from docs/ and compiler directives from simulate/ and analyze/
	os.system("find ./../ -maxdepth 3 \( -name \"*.out\" -o -name \"*.aux\" -o -name \"*.log\" -o -name \"*.fls\" -o -name \"*.bbl\" -o -name \"*.synctex.gz\" -o -name \"*.pyc\" -o -name \"*.so\" \) -type f -exec mv \'{}\' ./../.ignore/ \\; > /dev/null 2>&1")
	# os.system("mv simulate/build/ ./../.ignore/simulate_build > /dev/null 2>&1")
	# os.system("mv analyze/build/ ./../.ignore/analyze_build > /dev/null 2>&1")
	# Remove all backup files -- files ending with ~
	os.system("find ./../ -maxdepth 3 -name \"*~\" -type f -exec mv \'{}\' ./../.ignore/ \\; > /dev/null 2>&1")
	# remove compiler logs
	os.system("mv simulate/compiler_output.txt ./../.ignore/simulate_compiler.txt > /dev/null 2>&1")
	os.system("mv analyze/compiler_output.txt ./../.ignore/analyze_compiler.txt > /dev/null 2>&1")
	if (dist == 1):
		# Remove all c extension files
		os.system("find simulate/ -name \'*.c\' -type f -exec mv \'{}\' ./../.ignore/ \\; > /dev/null 2>&1")
		os.system("find analyze/ -name \'*.c\' -type f -exec mv \'{}\' ./../.ignore/ \\; > /dev/null 2>&1")
		# Remove all input files except for the template one.
		os.system("find ./../input ! -name \'sample_*.txt\' -type f -exec mv \'{}\' ./../.ignore/ \\; > /dev/null 2>&1")
		# Remove all physical channels
		os.system("mv ./../physical/*.npy ./../.ignore/ > /dev/null 2>&1")
	return None

if __name__ == '__main__':
	import numpy as np
	from distutils.core import setup
	from distutils.extension import Extension
	# This python script should be called as: python setup.py build_ext --inplace <cython> <compiler>
	# where cython is a flag that is either 1 or 0 dependeing on whether C files need to be generated from the cythonize command on the pyx files or not.
	# and compiler is the name of the compiler.
	# For setup(...) to work, we need to remove the last two shell arguments. Hence we use "remove" on sys.argv.
	######
	# loc = sys.argv[3]
	# sys.argv.pop(3)
	cython = 0
	if (int(sys.argv[3]) == 1):
		cython = 1
	sys.argv.pop(3)
	# Note that when the element at index 3 is removed, the subsequent element takes on index 3.
	compiler = sys.argv[3]
	sys.argv.pop(3)
	######
	files = [os.path.split(name)[1].split(".")[0] for name in os.listdir(".") if (os.path.splitext(name)[1] == ".pyx")]
	print("calling python %s\non the files\n%s" % (sys.argv, files))
	if (cython == 1):
		from Cython.Build import cythonize
		from Cython.Distutils.build_ext import build_ext
		ext = "pyx"
	else:
		from distutils.command.build_ext import build_ext
		ext = "c"
	build_ext.inplace = 1
	os.environ["CC"]=compiler
	if (compiler == "gcc"):
		os.environ["CFLAGS"] = "-lm -O3 -Wall -ffast-math -march=native -mfpmath=sse -fno-signed-zeros"
	extensions = []
	for i in range(len(files)):
		extensions.append(Extension("%s" % (files[i]), ["%s.%s" % (files[i], ext)], include_dirs = [np.get_include()], extra_compile_args=['-fopenmp'], extra_link_args=['-fopenmp'], language = 'c'))
	if (cython == 1):
		print("cythonizing extensions")
		extensions = cythonize(extensions)
	setup(
		name="extns",
		version="1.0",
		description="Compiled Cython extensions",
		ext_modules=extensions,
		cmdclass={'build_ext':build_ext},
	)